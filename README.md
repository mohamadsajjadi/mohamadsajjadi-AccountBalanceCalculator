## بخش اول 
### پرسش اول 
طبق چیزی که در کلاس گفته شد, مقدار حساب نمیتواند منفی باشد. در ازای انجام یکسری Transaction در صورتی که مقدار Withraw از مقدار Deposit بیشتر شود, در کد داده شده, مقدار Balance منفی می‌شود که نباید اینگونه باشد
### پرسش دوم 
آزمون نوشته شده به صورت زیر می‌باشد:
```
    @Test
    void checkNegativeBalanceHistory() {
        // balance can not be less than zero
        int oldBalance = AccountBalanceCalculator.calculateBalance(AccountBalanceCalculator.getTransactionHistory());
        Transaction transaction = new Transaction(TransactionType.WITHDRAWAL, 100);
        AccountBalanceCalculator.addTransaction(transaction);
        int balance = AccountBalanceCalculator.calculateBalance(AccountBalanceCalculator.getTransactionHistory());
        assertEquals(oldBalance, balance);
    }
```
و برای درست کردن آن به صورت زیر عمل میکنیم:
```
    public static void addTransaction(Transaction transaction) {
        if (transaction.getType() == TransactionType.WITHDRAWAL) {
            int newBalance = calculateBalance(transactionHistory) - transaction.getAmount();
            if (newBalance < 0){
                System.out.println("Not Enough Credit !");
                return;
            }
        }
        transactionHistory.add(transaction);
    }
```
### پرسش سوم 
 باعث می‌شود آزمون‌ها به صورت جانب‌دارانه طرح شوند(یعنی جوری طراحی شوند که درست کار کنند) و ممکن است خواسته‌های اصلی مصرف‌کننده فراموش شود. پس بهتر است که در ابتدا این آزمون‌ها و بر اساس خواست مصرف‌کننده طراحی شود

### پرسش چهارم
درواقع هنگامی که میخواهیم برنامه مان را توسعه دهیم اگر از ابتدا به فکر نوشتن تست باشیم مجبور می‌شویم که بیشتر و بهتر به ساختار برنامه‌مان دقت کنیم و انگار که همه چیز حساب شده جلو می‌رود و صرفا یک یونیت تست ساده نیست.

###  پرسش پنجم
مزایای روش ایجاد مبنی بر آزمون:
افزایش کیفیت کد:

چون قبل از پیاده‌سازی به رفتار صحیح سیستم فکر می‌شود، کدها دقیق‌تر و بدون رفتارهای غیرمنتظره نوشته می‌شوند.

کاهش باگ‌ها و اشکالات:

از آنجا که برای هر قابلیت تستی نوشته شده، بسیاری از خطاها پیش از رسیدن به مرحله نهایی شناسایی می‌شوند.

امکان تغییر و توسعه آسان‌تر:

وجود تست‌ها باعث می‌شود که توسعه‌دهنده بتواند با اطمینان بیشتری کد را تغییر دهد، بدون نگرانی از خراب شدن عملکردهای قبلی.

مستندسازی خودکار رفتار سیستم:

تست‌ها مثل یک مستند زنده عمل می‌کنند که رفتار مورد انتظار سیستم را نشان می‌دهند.

افزایش تمرکز برنامه‌نویس:

چون در هر مرحله فقط روی پیاده‌سازی یک قابلیت تمرکز می‌شود، کد مرتب‌تر و منسجم‌تری تولید می‌گردد.

معایب روش ایجاد مبنی بر آزمون:
نیاز به زمان بیشتر در ابتدا:

نوشتن تست‌ها قبل از پیاده‌سازی، در ابتدای کار زمان‌بر است و ممکن است در پروژه‌هایی با زمان محدود، چالش‌زا باشد.

نیاز به تجربه و مهارت بیشتر:

برای نوشتن تست‌های خوب، برنامه‌نویس باید به درک خوبی از طراحی و تحلیل سیستم برسد.

ممکن است باعث نوشتن تست‌های بی‌ارزش شود:

اگر هدف فقط پوشش‌دهی تست باشد و نه کیفیت واقعی، ممکن است تست‌هایی نوشته شود که ارزش واقعی ندارند.

مناسب نبودن برای پروژه‌های با نیازهای مبهم یا تغییرات زیاد:

اگر نیازمندی‌های پروژه به‌طور مداوم تغییر کند، باید مدام تست‌ها هم تغییر کنند که وقت‌گیر است.

پوشش ضعیف برای تست‌های رابط کاربری و گرافیکی:

نوشتن تست برای UI یا سیستم‌های تعاملی پیچیده‌تر از سیستم‌های منطقی و ممکن است در TDD به خوبی پوشش داده نشود.